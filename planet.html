<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>My first three.js app</title>
    <style>
        body { margin: 0; }
    </style>
</head>
<body>
    <canvas style="color:#87CEEB" id='canvas_noise' width='600' height='600' hidden>
    </canvas>
</body>
<script id="vs" type="x-shader/x-vertex">
    attribute vec3 aPosition;
    varying   vec3 vPosition;
    void main() {
        gl_Position = vec4(aPosition, 1.0);
        vPosition = aPosition;
    }
</script>

<script id="fs" type="x-shader/x-fragment">
    precision highp float;
    uniform float uTime;
    varying vec3 vPosition;
    uniform vec3 uCursor;

    #define OCTAVES 8
    #define FREQUENCY 3.77
    #define LACUNAIRTY 2.21

    vec2 randomGradient(in vec2 point) {
        // Random float. No precomputed gradients mean this works for any number of grid coordinates
        float random = uTime * sin(point.x * 21942. + point.y * 171324. + 8912.) * cos(point.x * 23157. * point.y * 217832. + 9758.);
        return vec2(cos(random), sin(random));
    }

    // Computes the dot product of the distance and gradient vectors.
    float dotGridGradient(vec2 point, vec2 st) {
        // Get gradient from integer coordinates
        vec2 gradient = randomGradient(point);

        return dot(gradient, st);
    }

    // Based on Morgan McGuire @morgan3d
    // https://www.shadertoy.com/view/4dS3Wd
    float noise (in vec2 st, in float frequency) {
        vec2 offset = st + FREQUENCY * 2.;
        return sin(offset.x * offset.y * FREQUENCY + uTime);
    }

    float perlin (in vec2 st, in float freq) {
        // a b <--- Point Layout
        // c d
        vec2 a = floor(st * freq);
        vec2 d = a + vec2(1, 1);
        vec2 b = a + vec2(1, 0);
        vec2 c = a + vec2(0, 1);
        if(a.x == -1. * freq) {
            a.x = freq;
            c.x = freq;
        }

        vec2 distance = fract(st * freq);

        vec2 offset = vec2(freq);
        float an = dotGridGradient(a, st);
        float bn = dotGridGradient(b, st);
        float x1 = mix(an, bn, distance.x);

        float cn = dotGridGradient(c, st);
        float dn = dotGridGradient(d, st);
        float x2 = mix(cn, dn, distance.x);

        return mix(x1, x2, distance.y);
    }

    float fbm (in vec2 st) {
        // Initial values
        float value = 0.0;
        float amplitude = 1.;
        float frequency = FREQUENCY;
        //
        // Loop of octaves
        for (int i = 0; i < OCTAVES; i++) {
            value += amplitude * perlin(st, frequency);
            frequency *= LACUNAIRTY;
            amplitude *= .5;
        }
        return value;
    }

    float map(in float value, in float y) {
        return  value + (1. - abs(y))/3.;
    }

    void main() {
        vec2 st = vec2(vPosition.xy);
        vec3 color = vec3(map(fbm(st), vPosition.y));

        gl_FragColor = vec4(color,1.0);
    }
</script>
<script type="module" src="./build/three.js"></script>
<script type="module" src="./js/utils.js"></script>
<!--<script src="https://cdnjs.cloudflare.com/ajax/libs/jimp/0.16.1/jimp.js" integrity="sha512-KRBWqeBNjT8WNu5DSvqDeuVoEUrqO70EiXv+fEx0dFOGqQTxEBEv0NDht0V9a7nPjZMGe11bpXveXAVgygqkHw==" crossorigin="anonymous"></script>-->
<script type="module" src="build/jimp.js"></script>
<script type="module" src="./custom/geometry_warp.js"></script>
<script src="js/gl_utils.js"></script>
<script type="module">
    // Create THREE.js scene
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
    camera.position.set(0, 0, 5);

    const renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );
    const geometry = new THREE.IcosahedronBufferGeometry(1.5, 64)

    // Generate Terrain Texture and load it into THREE.js
    start_gl("canvas_noise", getStringFromDOMElement('vs'), getStringFromDOMElement('fs'));
    const canvas = document.getElementById('canvas_noise');
    let base64_img = canvas.toDataURL();
    const loader = new THREE.TextureLoader();
    const displacement = loader.load(base64_img);
    const jimp_data = await Jimp.read(base64_img)
    .then(img => {
        img.color([
            { apply: 'hue', params: [-90] },
            { apply: 'lighten', params: [15] },
            { apply: 'xor', params: ['#06D'] }
        ]);

        // let original = img.clone()
        // let kernel = {name: "edgeenhance", kernel:
        //         [
        //             [-1,  -1, -1, -1, -1, -1, -1],
        //             [-1,  -1, -1, -1, -1, -1, -1],
        //             [-1,  -1, -1, -1, -1, -1, -1],
        //             [-1,  -1, -1, 45, -1, -1, -1],
        //             [-1,  -1, -1, -1, -1, -1, -1],
        //             [-1,  -1, -1, -1, -1, -1, -1],
        //             [-1,  -1, -1, -1, -1, -1, -1],
        //         ]}
        // let kernel = {name: "asdf", kernel:
        //         [
        //             [2,  -1, -1, -1, 2],
        //             [-1,  2, -1, 2, -1],
        //             [0,  -1, 0, -1, 0],
        //             [-1,  2, -1, 2, -1],
        //             [ 2,  -1, -1, -1, 2],
        //         ]}
        // let kernel = {name: "top-shadow", kernel:
        //         [
        //             [-1,  -1, 0, 1, 1],
        //             [-1,  -1, 0, 1, 1],
        //             [-1,  -1, 0, 1, 1],
        //             [-1,  -1, 0, 1, 1],
        //             [-1,  -1, 0, 1, 1],
        //         ]}
        let kernel = {name: "top-shadow", kernel:
                [
                    [1/16, 2/16, 1/16],
                    [2/16, 4/16, 2/16],
                    [1/16, 2/16, 1/16],
                ]}
        img.convolute(kernel.kernel)
        // img.composite(original, 0, 0, {
        //     mode: Jimp.BLEND_ADD,
        //     opacitySource: .9,
        //     opacityDest: .7
        // })

        img.getBase64(Jimp.AUTO, (err, res) => {
             base64_img = res
        })
    });
    const texture = loader.load( base64_img );


    const uniforms = {
        iTime: { value: 0 },
        iResolution:  { value: new THREE.Vector3() },
    };
    // const material = new THREE.ShaderMaterial({
    //     vertexShader: vertexShader,
    //     fragmentShader: fragmentShader,
    //     uniforms: uniforms,
    // });

    const material = new THREE.MeshStandardMaterial({
        color: 'lightblue',    // red (can also use a CSS color string here)


        map: texture,
        displacementMap: displacement,
        displacementScale: .1,
    });

    // material.onBeforeCompile = shader => {
        // console.log(shader.fragmentShader)
        // console.log(shader.vertexShader)
        // shader.fragmentShader = //this is the fragment program string in the template format
        //     shader.fragmentShader.replace( //we have to transform the string
        //         '#include <alphamap_fragment>', //we will swap out this chunk
        //         ''
        //     )
    // }


    const mesh = new THREE.Mesh(geometry, material)

    scene.add( mesh )

    const light1 = new THREE.PointLight( 0x446699, 0.7 );
    light1.position.set( 100, 100, 100 );
    scene.add( light1 );

    const light2 = new THREE.PointLight( 0xBBBBBB, 0.7 );
    light2.position.set( - 100, - 100, - 50 );
    scene.add( light2 );

    scene.add( new THREE.AmbientLight( 0x608f91) );

    // const wireframe = new THREE.WireframeGeometry( geometry );
    //
    // const line = new THREE.LineSegments( wireframe );
    // line.material.depthTest = false;
    // line.material.opacity = 0.25;
    // line.material.transparent = true;
    //
    // scene.add( line );





    function animate(time) {
        time *= 0.001

        mesh.rotation.y += 0.003;

        const canvas = renderer.domElement;
        uniforms.iResolution.value.set(canvas.width, canvas.height, 1);
        uniforms.iTime.value = time;

        renderer.render( scene, camera );
        requestAnimationFrame( animate );
    }
    animate();
</script>
</html>
