<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>My first three.js app</title>
    <style>
        body { margin: 0; }
    </style>
</head>
<body>
<script type="module" src="./build/three.js"></script>
<!--<script type="module" src="./build/orbitcontrols.js"></script>-->
<script type="module" src="./js/spheremap.js"></script>
<script type="module" src="./js/utils.js"></script>
<script type="module" src="./custom/geometry_warp.js"></script>
<script type="module">
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
    camera.position.set(0, 0, 5);

    const renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    const geometry = SS.warp.geometry_warp(SS.spheremap.Sphere(1.5))


    const loader = new THREE.TextureLoader();
    const texture = loader.load('assets/flower-1.jpg');
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.magFilter = THREE.NearestFilter;
    const repeats = 1;
    texture.repeat.set(repeats, repeats);

    const fragmentShader = `
  #include <common>

  uniform vec3 iResolution;
  uniform float iTime;

  // By iq: https://www.shadertoy.com/user/iq
  // license: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
  void mainImage( out vec4 fragColor, in vec2 fragCoord )
  {
      // Normalized pixel coordinates (from 0 to 1)
      vec2 uv = fragCoord/iResolution.xy;

      // Time varying pixel color
      vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));

      // Output to screen
      fragColor = vec4(col,1.0);
  }

  void main() {
    mainImage(gl_FragColor, gl_FragCoord.xy);
  }
  `

    const vertexShader = `
    #include <common>
    varying vec3 vUv;

    void main() {
      vUv = position;

      vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
      gl_Position = projectionMatrix * modelViewPosition;
    }
    `

    const uniforms = {
        iTime: { value: 0 },
        iResolution:  { value: new THREE.Vector3() },
    };
    // const material = new THREE.ShaderMaterial({
    //     vertexShader: vertexShader,
    //     fragmentShader: fragmentShader,
    //     uniforms: uniforms,
    // });

    const material = new THREE.MeshLambertMaterial({
        color: 0xFF0000,    // red (can also use a CSS color string here)
    });

    const mesh = new THREE.Mesh(geometry, material)

    // scene.add( mesh )

    const light = new THREE.HemisphereLight(0xFFFFFF, 0x444444, 1)

    scene.add(light)

    const wireframe = new THREE.WireframeGeometry( geometry );

    const line = new THREE.LineSegments( wireframe );
    line.material.depthTest = false;
    line.material.opacity = 0.25;
    line.material.transparent = true;

    scene.add( line );





    function animate(time) {
        time *= 0.001

        line.rotation.x += 0.001;
        line.rotation.y += 0.001;

        const canvas = renderer.domElement;
        uniforms.iResolution.value.set(canvas.width, canvas.height, 1);
        uniforms.iTime.value = time;

        renderer.render( scene, camera );
        requestAnimationFrame( animate );
    }
    animate();
</script>
</body>
</html>
